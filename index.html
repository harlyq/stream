<!DOCTYPE html>
<html>
  <head>
    <script>
      (function() {
        function stream(f) {
          this.f = f
          this.children = []
        }
        
        stream.prototype.pipe = function(f) {
          // chained pipe() will be children of children
          var s = new stream(f)
          this.children.push(s)
          return s
        }
        
        stream.prototype.reset = function() {}
        
        stream.prototype.push = function(x) {
          var y = (typeof this.f === 'function') ? this.f.call(null, x) : x
            
          // each child receives the same data
          if (typeof y !== 'undefined') {
            for (var i = 0; i < this.children.length; ++i) {
              this.children[i].push(y)
            }
          }
        }
        
        stream.prototype.map = function(f) {
          return this.pipe((x) => { 
            return f.call(null, x) 
          })
        }
        
        stream.prototype.filter = function(f) {
          return this.pipe((x) => { 
            if (f.call(null, x)) {
              return x 
            }
          })
        }

        // f(f0, x) the first parameter is the state, the second is the new value
        stream.prototype.fold = function(f, f0) {
          return this.pipe((x) => { 
            var f1 = f.call(null, f0, x)
            if (typeof f1 !== 'undefined') {
              f0 = f1 // replace the old starting value
              return f1
            }
          })
        }

        stream.prototype.log = function() {
          return this.pipe((x) => {
            console.log(x)
          })
        }
        
        stream.prototype.split = function(i) {
          return this.pipe((x) => {
            return x[i]
          })
        }
        
        function eventStream(selector, name) {
          var s = new stream()
          var handler = function(e) {
            s.push(e)
          }          
          var elements = document.querySelectorAll(selector)
          
          s.reset = function() {
            element.removeEventListener(name, handler)
          }
          
          for (var i = 0; i < elements.length; ++i) {
            elements[i].addEventListener(name, handler)
          }
          
          return s
        }
        
        function intervalStream(periodms) {
          var s = new stream()
          var count = 0          
          var id = setInterval(() => { s.push(++count) }, periodms)
          
          s.reset = function() {
            clearTimeout(id)
          }
          return s
        }
        
        // each argument is a stream to merge
        function mergeStreams(mode) {          
          var numStreams = arguments.length - 1
          var buffer = []
          var s = new stream()
          var addPipe = function(child, mode, index) {
            child.pipe((x) => {
              buffer[index] = x // remember stream's value
              
              var numReady = 0
              for (var k = 0; k < numStreams; ++k) {
                if (typeof buffer[k] !== "undefined") {
                  numReady++
                }
              }
              
              var isReady = false
              if (mode === "all")
                isReady = numReady == numStreams
              else if (mode === "any")
                isReady = numReady > 0
              else if (typeof mode === "number")
                isReady = numReady > mode

              if (isReady) {
                var result = buffer.slice()
                buffer.length = 0
                s.push(result) // start merged stream
              }
              
              return x // continue individual streams
            })
          }
          
          for (var i = 0; i < numStreams; ++i) {
            addPipe(arguments[i + 1], mode, i)
          }

          return s
        }
        
        var canvas = function(selector) {
          this.can = document.querySelector(selector)
          this.buffer = document.createElement('canvas')
          this.buffer.width = this.can.width
          this.buffer.height = this.can.height
          
          this.ctx = this.buffer.getContext('2d')
          this.mainctx = this.can.getContext('2d')
          return this
        }
        
        canvas.prototype.image = function(src, dx, dy) {
            var self = this
            if (!this.img) {
              this.img = new Image()
            }
            this.img.src = src  // may have to load image
            self.ctx.drawImage(self.img, dx, dy)
            return this
        }
        
        canvas.prototype.clear = function() {
          this.ctx.fillStyle = "white"
          this.ctx.fillRect(0, 0, this.buffer.width, this.buffer.height)
          return this
        }
        
        canvas.prototype.render = function() {
          this.mainctx.drawImage(this.buffer, 0, 0)
        }
        
        window.addEventListener('load', function() {
          var s = new eventStream('#button1', 'click')
          var t = new intervalStream(5000)
          // var a = s.map((x) => {return 1;})
          // var b = s.log()
          // var c = a.log()
          var d = s.fold((count, x) => {return ++count;}, 0).log()
          // var e = t.log()
          var f = new mergeStreams("all", s, t).log()

          var update = function(data, newpoint) {
            data.x = newpoint.x
            data.y = newpoint.y
            return data
          }
          
          var page = new canvas("#canvas")
          var draw = function(point) {
            page.clear().image("mario.png", point.x, point.y).render()
          }
          
          // todo offset x and y by element position
          var click = new eventStream('#canvas', 'mousemove')
          click.map((evt) => { return {x: evt.x, y: evt.y}}).fold(update, {x:0, y:0}).pipe(draw)
          
          var x = new eventStream('button','click')
          x.map((e) => 'clicked ' + e.target.id).log()
          
          // mutating r, should we make a copy?
          // yes, so then we should use an object paradigm for mutations e.g. rect.move()?
          // no because we want to have generic functions so we 'move' anything with an x and a y
          // not just 'rect'
          // mutation is cheap and copy is expensive, we could use record structures which
          // remember their mutations (zippers?), but this makes access and update more expensive
          var rect = function(w, h) { return {type:'rect', x:0, y:0, w:w, h:h, fill:'none', line:'black'} }
          var move = function(r, x, y) { r.x += x; r.y += y; return r }
          var fill = function(r, col) { r.fill = col; return r }
          var clear = function(col) { return {type:'clear', fill:col} }
          var copy = function(obj) { 
            var n = {}
            for (var attr in obj) {
              if (obj.hasOwnProperty(attr))
                n[attr] = obj[attr]
            }
              
            return n            
          }
          var collage = function(w, h, shapes) {
            var canvas = document.createElement('canvas')
            var ctx = canvas.getContext('2d')
            canvas.width = w
            canvas.height = h
            
            for (var i = 0; i < shapes.length; ++i) {
              var shape = shapes[i]
              switch (shape.type) {
                case 'clear':
                  ctx.fillStyle = shape.fill
                  ctx.fillRect(0, 0, w, h)
                  break;
                  
                case 'rect':
                  if (shape.fill !== 'none') {
                    ctx.fillStyle = shape.fill
                    ctx.fillRect(shape.x, shape.y, shape.w, shape.h)
                  }
                  if (shape.line !== 'none') {
                    ctx.strokeStyle = shape.line
                    ctx.strokeRect(shape.x, shape.y, shape.w, shape.h)
                  }
                  break
              }
            }
            return canvas
          }
          
          function rect1(w, h) {
            r = rect(w, h)
            r = move(r, 10, 10)
            f = fill(r, "green")
            return r
          }
          var myCollage = collage(50, 50, [clear('lightgray'), rect1(30, 20)])
          var canvas2 = document.querySelector('#canvas2')
          var ctx2 = canvas2.getContext('2d')
          ctx2.drawImage(myCollage, 0, 0)
        })
      })()
    </script>
  </head>
  <body>
    <button id="button1">Click 1</button>
    <button id="button2">Click 2</button>
    <button id="button3">Click 3</button>
    <div></div>
    <canvas id="canvas" width="400" height="400"></canvas>
    <canvas id="canvas2" width="400" height="400"></canvas>
  </body>
</html>
  