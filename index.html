<!DOCTYPE html>
<html>
  <head>
    <script>
      (function() {
        function stream(f) {
          this.f = f
          this.children = []
        }
        
        stream.prototype.pipe = function(f) {
          // chained pipe() will be children of children
          var s = new stream(f)
          this.children.push(s)
          return s
        }
        
        stream.prototype.reset = function() {}
        
        stream.prototype.push = function(x) {
          var y = (typeof this.f === 'function') ? this.f.call(null, x) : x
            
          // each child receives the same data
          if (typeof y !== 'undefined') {
            for (var i = 0; i < this.children.length; ++i) {
              this.children[i].push(y)
            }
          }
        }
        
        stream.prototype.map = function(f) {
          return this.pipe((x) => { 
            return f.call(null, x) 
          })
        }
        
        stream.prototype.filter = function(f) {
          return this.pipe((x) => { 
            if (f.call(null, x)) {
              return x 
            }
          })
        }

        // f(f0, x) the first parameter is the state, the second is the new value
        stream.prototype.fold = function(f, f0) {
          return this.pipe((x) => { 
            var f1 = f.call(null, f0, x)
            if (typeof f1 !== 'undefined') {
              f0 = f1 // replace the old starting value
              return f1
            }
          })
        }

        stream.prototype.log = function() {
          return this.pipe((x) => {
            console.log(x)
          })
        }
        
        stream.prototype.split = function(i) {
          return this.pipe((x) => {
            return x[i]
          })
        }
        
        function eventStream(selector, name) {
          var s = new stream()
          var handler = function(e) {
            s.push(e)
          }          
          var element = document.querySelector(selector)
          
          s.reset = function() {
            element.removeEventListener(name, handler)
          }
          
          element.addEventListener(name, handler)
          return s
        }
        
        function intervalStream(periodms) {
          var s = new stream()
          var count = 0          
          var id = setInterval(() => { s.push(++count) }, periodms)
          
          s.reset = function() {
            clearTimeout(id)
          }
          return s
        }
        
        // each argument is a stream to merge
        function mergeStreams() {          
          var numStreams = arguments.length
          var buffer = []
          var s = new stream()
          var addPipe = function(child, index) {
            child.pipe((x) => {
              buffer[index] = x // remember stream's value
              
              var numReady = 0
              for (var k = 0; k < numStreams; ++k) {
                if (typeof buffer[k] !== "undefined") {
                  numReady++
                }
              }
              if (numReady == numStreams) {
                var result = buffer.slice()
                buffer.length = 0
                s.push(result) // start merged stream
              }
              
              return x // continue individual streams
            })
          }
          
          for (var i = 0; i < numStreams; ++i) {
            addPipe(arguments[i], i)
          }

          return s
        }
        
        var canvas = function(selector) {
          this.can = document.querySelector(selector)
          this.ctx = this.can.getContext('2d')
          return this
        }
        
        canvas.prototype.image = function(src, dx, dy) {
            var self = this
            if (!this.img) {
              this.img = new Image()
            }
            this.img.src = src
            this.img.onload = function() {
              self.ctx.drawImage(self.img, dx, dy)
            }
            return this
        }
        
        canvas.prototype.clear = function() {
          this.ctx.clearRect(0, 0, this.can.width, this.can.height)
          return this
        }
        
        window.addEventListener('load', function() {
          var s = new eventStream('#button', 'click')
          var t = new intervalStream(5000)
          // var a = s.map((x) => {return 1;})
          // var b = s.log()
          // var c = a.log()
          var d = s.fold((count, x) => {return ++count;}, 0).log()
          // var e = t.log()
          var f = new mergeStreams(s, t).log()

          var update = function(data, newpoint) {
            data.x = newpoint.x
            data.y = newpoint.y
            return data
          }
          
          var page = new canvas("#canvas")
          var draw = function(point) {
            page.clear().image("mario.png", point.x, point.y)
          }
          
          // todo offset x and y by element position
          var click = new eventStream('#canvas', 'mousemove')
          click.map((evt) => { return {x: evt.x, y: evt.y}}).fold(update, {x:0, y:0}).pipe(draw)
        })
      })()
    </script>
  </head>
  <body>
    <button id="button">Click</button>
    <div></div>
    <canvas id="canvas" width="400" height="400"></canvas>
  </body>
</html>
  